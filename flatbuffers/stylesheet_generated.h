// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STYLESHEET_STYLES_H_
#define FLATBUFFERS_GENERATED_STYLESHEET_STYLES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Styles {

struct String;
struct StringBuilder;

struct Integer;
struct IntegerBuilder;

struct Double;
struct DoubleBuilder;

struct Boolean;
struct BooleanBuilder;

struct StringArray;
struct StringArrayBuilder;

struct IntegerArray;
struct IntegerArrayBuilder;

struct DoubleArray;
struct DoubleArrayBuilder;

struct ObjectArray;
struct ObjectArrayBuilder;

struct IntegereArrayArray;
struct IntegereArrayArrayBuilder;

struct DoubleArrayArray;
struct DoubleArrayArrayBuilder;

struct KeyValue;
struct KeyValueBuilder;

struct Object;
struct ObjectBuilder;

struct DeclarationTuple;
struct DeclarationTupleBuilder;

struct Selector;
struct SelectorBuilder;

struct PseudoKey;
struct PseudoKeyBuilder;

struct KeyValueString;
struct KeyValueStringBuilder;

struct Style;
struct StyleBuilder;

struct Font;
struct FontBuilder;

struct PrimitiveCondition;
struct PrimitiveConditionBuilder;

struct CompoundCondition;
struct CompoundConditionBuilder;

struct Condition;
struct ConditionBuilder;

struct Media;
struct MediaBuilder;

struct StyleSheet;
struct StyleSheetBuilder;

enum Value : uint8_t {
  Value_NONE = 0,
  Value_String = 1,
  Value_Integer = 2,
  Value_Double = 3,
  Value_Boolean = 4,
  Value_StringArray = 5,
  Value_IntegerArray = 6,
  Value_DoubleArray = 7,
  Value_Object = 8,
  Value_ObjectArray = 9,
  Value_IntegereArrayArray = 10,
  Value_DoubleArrayArray = 11,
  Value_MIN = Value_NONE,
  Value_MAX = Value_DoubleArrayArray
};

inline const Value (&EnumValuesValue())[12] {
  static const Value values[] = {
    Value_NONE,
    Value_String,
    Value_Integer,
    Value_Double,
    Value_Boolean,
    Value_StringArray,
    Value_IntegerArray,
    Value_DoubleArray,
    Value_Object,
    Value_ObjectArray,
    Value_IntegereArrayArray,
    Value_DoubleArrayArray
  };
  return values;
}

inline const char * const *EnumNamesValue() {
  static const char * const names[13] = {
    "NONE",
    "String",
    "Integer",
    "Double",
    "Boolean",
    "StringArray",
    "IntegerArray",
    "DoubleArray",
    "Object",
    "ObjectArray",
    "IntegereArrayArray",
    "DoubleArrayArray",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue(Value e) {
  if (::flatbuffers::IsOutRange(e, Value_NONE, Value_DoubleArrayArray)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue()[index];
}

template<typename T> struct ValueTraits {
  static const Value enum_value = Value_NONE;
};

template<> struct ValueTraits<Styles::String> {
  static const Value enum_value = Value_String;
};

template<> struct ValueTraits<Styles::Integer> {
  static const Value enum_value = Value_Integer;
};

template<> struct ValueTraits<Styles::Double> {
  static const Value enum_value = Value_Double;
};

template<> struct ValueTraits<Styles::Boolean> {
  static const Value enum_value = Value_Boolean;
};

template<> struct ValueTraits<Styles::StringArray> {
  static const Value enum_value = Value_StringArray;
};

template<> struct ValueTraits<Styles::IntegerArray> {
  static const Value enum_value = Value_IntegerArray;
};

template<> struct ValueTraits<Styles::DoubleArray> {
  static const Value enum_value = Value_DoubleArray;
};

template<> struct ValueTraits<Styles::Object> {
  static const Value enum_value = Value_Object;
};

template<> struct ValueTraits<Styles::ObjectArray> {
  static const Value enum_value = Value_ObjectArray;
};

template<> struct ValueTraits<Styles::IntegereArrayArray> {
  static const Value enum_value = Value_IntegereArrayArray;
};

template<> struct ValueTraits<Styles::DoubleArrayArray> {
  static const Value enum_value = Value_DoubleArrayArray;
};

bool VerifyValue(::flatbuffers::Verifier &verifier, const void *obj, Value type);
bool VerifyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ConditionValue : uint8_t {
  ConditionValue_NONE = 0,
  ConditionValue_PrimitiveCondition = 1,
  ConditionValue_CompoundCondition = 2,
  ConditionValue_MIN = ConditionValue_NONE,
  ConditionValue_MAX = ConditionValue_CompoundCondition
};

inline const ConditionValue (&EnumValuesConditionValue())[3] {
  static const ConditionValue values[] = {
    ConditionValue_NONE,
    ConditionValue_PrimitiveCondition,
    ConditionValue_CompoundCondition
  };
  return values;
}

inline const char * const *EnumNamesConditionValue() {
  static const char * const names[4] = {
    "NONE",
    "PrimitiveCondition",
    "CompoundCondition",
    nullptr
  };
  return names;
}

inline const char *EnumNameConditionValue(ConditionValue e) {
  if (::flatbuffers::IsOutRange(e, ConditionValue_NONE, ConditionValue_CompoundCondition)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConditionValue()[index];
}

template<typename T> struct ConditionValueTraits {
  static const ConditionValue enum_value = ConditionValue_NONE;
};

template<> struct ConditionValueTraits<Styles::PrimitiveCondition> {
  static const ConditionValue enum_value = ConditionValue_PrimitiveCondition;
};

template<> struct ConditionValueTraits<Styles::CompoundCondition> {
  static const ConditionValue enum_value = ConditionValue_CompoundCondition;
};

bool VerifyConditionValue(::flatbuffers::Verifier &verifier, const void *obj, ConditionValue type);
bool VerifyConditionValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct String FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(String::VT_VALUE, value);
  }
  explicit StringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<String>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<String> CreateString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<String> CreateStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return Styles::CreateString(
      _fbb,
      value__);
}

struct Integer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntegerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct IntegerBuilder {
  typedef Integer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(Integer::VT_VALUE, value, 0);
  }
  explicit IntegerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Integer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Integer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Integer> CreateInteger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  IntegerBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Double FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DoubleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  typedef Double Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
  }
  explicit DoubleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Double> CreateDouble(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Boolean FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BooleanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct BooleanBuilder {
  typedef Boolean Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(Boolean::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BooleanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Boolean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Boolean>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Boolean> CreateBoolean(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BooleanBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct StringArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfStrings(values()) &&
           verifier.EndTable();
  }
};

struct StringArrayBuilder {
  typedef StringArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> values) {
    fbb_.AddOffset(StringArray::VT_VALUES, values);
  }
  explicit StringArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringArray> CreateStringArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> values = 0) {
  StringArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StringArray> CreateStringArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*values) : 0;
  return Styles::CreateStringArray(
      _fbb,
      values__);
}

struct IntegerArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntegerArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<int64_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
};

struct IntegerArrayBuilder {
  typedef IntegerArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> values) {
    fbb_.AddOffset(IntegerArray::VT_VALUES, values);
  }
  explicit IntegerArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntegerArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntegerArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntegerArray> CreateIntegerArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> values = 0) {
  IntegerArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntegerArray> CreateIntegerArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<int64_t>(*values) : 0;
  return Styles::CreateIntegerArray(
      _fbb,
      values__);
}

struct DoubleArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DoubleArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<double> *values() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
};

struct DoubleArrayBuilder {
  typedef DoubleArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<double>> values) {
    fbb_.AddOffset(DoubleArray::VT_VALUES, values);
  }
  explicit DoubleArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DoubleArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DoubleArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DoubleArray> CreateDoubleArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> values = 0) {
  DoubleArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DoubleArray> CreateDoubleArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<double>(*values) : 0;
  return Styles::CreateDoubleArray(
      _fbb,
      values__);
}

struct ObjectArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValue>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValue>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct ObjectArrayBuilder {
  typedef ObjectArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValue>>> values) {
    fbb_.AddOffset(ObjectArray::VT_VALUES, values);
  }
  explicit ObjectArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectArray> CreateObjectArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValue>>> values = 0) {
  ObjectArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ObjectArray> CreateObjectArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Styles::KeyValue>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<Styles::KeyValue>>(*values) : 0;
  return Styles::CreateObjectArray(
      _fbb,
      values__);
}

struct IntegereArrayArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntegereArrayArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::IntegerArray>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::IntegerArray>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct IntegereArrayArrayBuilder {
  typedef IntegereArrayArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::IntegerArray>>> values) {
    fbb_.AddOffset(IntegereArrayArray::VT_VALUES, values);
  }
  explicit IntegereArrayArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntegereArrayArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntegereArrayArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntegereArrayArray> CreateIntegereArrayArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::IntegerArray>>> values = 0) {
  IntegereArrayArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntegereArrayArray> CreateIntegereArrayArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Styles::IntegerArray>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<Styles::IntegerArray>>(*values) : 0;
  return Styles::CreateIntegereArrayArray(
      _fbb,
      values__);
}

struct DoubleArrayArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DoubleArrayArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::DoubleArray>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::DoubleArray>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct DoubleArrayArrayBuilder {
  typedef DoubleArrayArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::DoubleArray>>> values) {
    fbb_.AddOffset(DoubleArrayArray::VT_VALUES, values);
  }
  explicit DoubleArrayArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DoubleArrayArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DoubleArrayArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DoubleArrayArray> CreateDoubleArrayArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::DoubleArray>>> values = 0) {
  DoubleArrayArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DoubleArrayArray> CreateDoubleArrayArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Styles::DoubleArray>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<Styles::DoubleArray>>(*values) : 0;
  return Styles::CreateDoubleArrayArray(
      _fbb,
      values__);
}

struct KeyValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  Styles::Value value_type() const {
    return static_cast<Styles::Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Styles::String *value_as_String() const {
    return value_type() == Styles::Value_String ? static_cast<const Styles::String *>(value()) : nullptr;
  }
  const Styles::Integer *value_as_Integer() const {
    return value_type() == Styles::Value_Integer ? static_cast<const Styles::Integer *>(value()) : nullptr;
  }
  const Styles::Double *value_as_Double() const {
    return value_type() == Styles::Value_Double ? static_cast<const Styles::Double *>(value()) : nullptr;
  }
  const Styles::Boolean *value_as_Boolean() const {
    return value_type() == Styles::Value_Boolean ? static_cast<const Styles::Boolean *>(value()) : nullptr;
  }
  const Styles::StringArray *value_as_StringArray() const {
    return value_type() == Styles::Value_StringArray ? static_cast<const Styles::StringArray *>(value()) : nullptr;
  }
  const Styles::IntegerArray *value_as_IntegerArray() const {
    return value_type() == Styles::Value_IntegerArray ? static_cast<const Styles::IntegerArray *>(value()) : nullptr;
  }
  const Styles::DoubleArray *value_as_DoubleArray() const {
    return value_type() == Styles::Value_DoubleArray ? static_cast<const Styles::DoubleArray *>(value()) : nullptr;
  }
  const Styles::Object *value_as_Object() const {
    return value_type() == Styles::Value_Object ? static_cast<const Styles::Object *>(value()) : nullptr;
  }
  const Styles::ObjectArray *value_as_ObjectArray() const {
    return value_type() == Styles::Value_ObjectArray ? static_cast<const Styles::ObjectArray *>(value()) : nullptr;
  }
  const Styles::IntegereArrayArray *value_as_IntegereArrayArray() const {
    return value_type() == Styles::Value_IntegereArrayArray ? static_cast<const Styles::IntegereArrayArray *>(value()) : nullptr;
  }
  const Styles::DoubleArrayArray *value_as_DoubleArrayArray() const {
    return value_type() == Styles::Value_DoubleArrayArray ? static_cast<const Styles::DoubleArrayArray *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Styles::String *KeyValue::value_as<Styles::String>() const {
  return value_as_String();
}

template<> inline const Styles::Integer *KeyValue::value_as<Styles::Integer>() const {
  return value_as_Integer();
}

template<> inline const Styles::Double *KeyValue::value_as<Styles::Double>() const {
  return value_as_Double();
}

template<> inline const Styles::Boolean *KeyValue::value_as<Styles::Boolean>() const {
  return value_as_Boolean();
}

template<> inline const Styles::StringArray *KeyValue::value_as<Styles::StringArray>() const {
  return value_as_StringArray();
}

template<> inline const Styles::IntegerArray *KeyValue::value_as<Styles::IntegerArray>() const {
  return value_as_IntegerArray();
}

template<> inline const Styles::DoubleArray *KeyValue::value_as<Styles::DoubleArray>() const {
  return value_as_DoubleArray();
}

template<> inline const Styles::Object *KeyValue::value_as<Styles::Object>() const {
  return value_as_Object();
}

template<> inline const Styles::ObjectArray *KeyValue::value_as<Styles::ObjectArray>() const {
  return value_as_ObjectArray();
}

template<> inline const Styles::IntegereArrayArray *KeyValue::value_as<Styles::IntegereArrayArray>() const {
  return value_as_IntegereArrayArray();
}

template<> inline const Styles::DoubleArrayArray *KeyValue::value_as<Styles::DoubleArrayArray>() const {
  return value_as_DoubleArrayArray();
}

struct KeyValueBuilder {
  typedef KeyValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value_type(Styles::Value value_type) {
    fbb_.AddElement<uint8_t>(KeyValue::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyValue> CreateKeyValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    Styles::Value value_type = Styles::Value_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    Styles::Value value_type = Styles::Value_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return Styles::CreateKeyValue(
      _fbb,
      key__,
      value_type,
      value);
}

struct Object FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValue>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValue>> *>(VT_FIELDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           verifier.EndTable();
  }
};

struct ObjectBuilder {
  typedef Object Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValue>>> fields) {
    fbb_.AddOffset(Object::VT_FIELDS, fields);
  }
  explicit ObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Object>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Object> CreateObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValue>>> fields = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_fields(fields);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Object> CreateObjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Styles::KeyValue>> *fields = nullptr) {
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<Styles::KeyValue>>(*fields) : 0;
  return Styles::CreateObject(
      _fbb,
      fields__);
}

struct DeclarationTuple FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeclarationTupleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTY_ID = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8,
    VT_FLAG = 10
  };
  uint8_t property_id() const {
    return GetField<uint8_t>(VT_PROPERTY_ID, 0);
  }
  Styles::Value value_type() const {
    return static_cast<Styles::Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Styles::String *value_as_String() const {
    return value_type() == Styles::Value_String ? static_cast<const Styles::String *>(value()) : nullptr;
  }
  const Styles::Integer *value_as_Integer() const {
    return value_type() == Styles::Value_Integer ? static_cast<const Styles::Integer *>(value()) : nullptr;
  }
  const Styles::Double *value_as_Double() const {
    return value_type() == Styles::Value_Double ? static_cast<const Styles::Double *>(value()) : nullptr;
  }
  const Styles::Boolean *value_as_Boolean() const {
    return value_type() == Styles::Value_Boolean ? static_cast<const Styles::Boolean *>(value()) : nullptr;
  }
  const Styles::StringArray *value_as_StringArray() const {
    return value_type() == Styles::Value_StringArray ? static_cast<const Styles::StringArray *>(value()) : nullptr;
  }
  const Styles::IntegerArray *value_as_IntegerArray() const {
    return value_type() == Styles::Value_IntegerArray ? static_cast<const Styles::IntegerArray *>(value()) : nullptr;
  }
  const Styles::DoubleArray *value_as_DoubleArray() const {
    return value_type() == Styles::Value_DoubleArray ? static_cast<const Styles::DoubleArray *>(value()) : nullptr;
  }
  const Styles::Object *value_as_Object() const {
    return value_type() == Styles::Value_Object ? static_cast<const Styles::Object *>(value()) : nullptr;
  }
  const Styles::ObjectArray *value_as_ObjectArray() const {
    return value_type() == Styles::Value_ObjectArray ? static_cast<const Styles::ObjectArray *>(value()) : nullptr;
  }
  const Styles::IntegereArrayArray *value_as_IntegereArrayArray() const {
    return value_type() == Styles::Value_IntegereArrayArray ? static_cast<const Styles::IntegereArrayArray *>(value()) : nullptr;
  }
  const Styles::DoubleArrayArray *value_as_DoubleArrayArray() const {
    return value_type() == Styles::Value_DoubleArrayArray ? static_cast<const Styles::DoubleArrayArray *>(value()) : nullptr;
  }
  uint8_t flag() const {
    return GetField<uint8_t>(VT_FLAG, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROPERTY_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           VerifyField<uint8_t>(verifier, VT_FLAG, 1) &&
           verifier.EndTable();
  }
};

template<> inline const Styles::String *DeclarationTuple::value_as<Styles::String>() const {
  return value_as_String();
}

template<> inline const Styles::Integer *DeclarationTuple::value_as<Styles::Integer>() const {
  return value_as_Integer();
}

template<> inline const Styles::Double *DeclarationTuple::value_as<Styles::Double>() const {
  return value_as_Double();
}

template<> inline const Styles::Boolean *DeclarationTuple::value_as<Styles::Boolean>() const {
  return value_as_Boolean();
}

template<> inline const Styles::StringArray *DeclarationTuple::value_as<Styles::StringArray>() const {
  return value_as_StringArray();
}

template<> inline const Styles::IntegerArray *DeclarationTuple::value_as<Styles::IntegerArray>() const {
  return value_as_IntegerArray();
}

template<> inline const Styles::DoubleArray *DeclarationTuple::value_as<Styles::DoubleArray>() const {
  return value_as_DoubleArray();
}

template<> inline const Styles::Object *DeclarationTuple::value_as<Styles::Object>() const {
  return value_as_Object();
}

template<> inline const Styles::ObjectArray *DeclarationTuple::value_as<Styles::ObjectArray>() const {
  return value_as_ObjectArray();
}

template<> inline const Styles::IntegereArrayArray *DeclarationTuple::value_as<Styles::IntegereArrayArray>() const {
  return value_as_IntegereArrayArray();
}

template<> inline const Styles::DoubleArrayArray *DeclarationTuple::value_as<Styles::DoubleArrayArray>() const {
  return value_as_DoubleArrayArray();
}

struct DeclarationTupleBuilder {
  typedef DeclarationTuple Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_property_id(uint8_t property_id) {
    fbb_.AddElement<uint8_t>(DeclarationTuple::VT_PROPERTY_ID, property_id, 0);
  }
  void add_value_type(Styles::Value value_type) {
    fbb_.AddElement<uint8_t>(DeclarationTuple::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(DeclarationTuple::VT_VALUE, value);
  }
  void add_flag(uint8_t flag) {
    fbb_.AddElement<uint8_t>(DeclarationTuple::VT_FLAG, flag, 0);
  }
  explicit DeclarationTupleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeclarationTuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeclarationTuple>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeclarationTuple> CreateDeclarationTuple(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t property_id = 0,
    Styles::Value value_type = Styles::Value_NONE,
    ::flatbuffers::Offset<void> value = 0,
    uint8_t flag = 0) {
  DeclarationTupleBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_flag(flag);
  builder_.add_value_type(value_type);
  builder_.add_property_id(property_id);
  return builder_.Finish();
}

struct Selector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SelectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRING_VALUE = 4,
    VT_INTEGER_VALUE = 6,
    VT_IS_STRING = 8
  };
  const ::flatbuffers::String *string_value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STRING_VALUE);
  }
  uint8_t integer_value() const {
    return GetField<uint8_t>(VT_INTEGER_VALUE, 0);
  }
  bool is_string() const {
    return GetField<uint8_t>(VT_IS_STRING, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRING_VALUE) &&
           verifier.VerifyString(string_value()) &&
           VerifyField<uint8_t>(verifier, VT_INTEGER_VALUE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_STRING, 1) &&
           verifier.EndTable();
  }
};

struct SelectorBuilder {
  typedef Selector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_string_value(::flatbuffers::Offset<::flatbuffers::String> string_value) {
    fbb_.AddOffset(Selector::VT_STRING_VALUE, string_value);
  }
  void add_integer_value(uint8_t integer_value) {
    fbb_.AddElement<uint8_t>(Selector::VT_INTEGER_VALUE, integer_value, 0);
  }
  void add_is_string(bool is_string) {
    fbb_.AddElement<uint8_t>(Selector::VT_IS_STRING, static_cast<uint8_t>(is_string), 0);
  }
  explicit SelectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Selector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Selector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Selector> CreateSelector(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> string_value = 0,
    uint8_t integer_value = 0,
    bool is_string = false) {
  SelectorBuilder builder_(_fbb);
  builder_.add_string_value(string_value);
  builder_.add_is_string(is_string);
  builder_.add_integer_value(integer_value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Selector> CreateSelectorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *string_value = nullptr,
    uint8_t integer_value = 0,
    bool is_string = false) {
  auto string_value__ = string_value ? _fbb.CreateString(string_value) : 0;
  return Styles::CreateSelector(
      _fbb,
      string_value__,
      integer_value,
      is_string);
}

struct PseudoKey FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PseudoKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTEGER_VALUE = 4,
    VT_BOOL_VALUE = 6,
    VT_IS_INT = 8
  };
  int8_t integer_value() const {
    return GetField<int8_t>(VT_INTEGER_VALUE, 0);
  }
  bool bool_value() const {
    return GetField<uint8_t>(VT_BOOL_VALUE, 0) != 0;
  }
  bool is_int() const {
    return GetField<uint8_t>(VT_IS_INT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_INTEGER_VALUE, 1) &&
           VerifyField<uint8_t>(verifier, VT_BOOL_VALUE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_INT, 1) &&
           verifier.EndTable();
  }
};

struct PseudoKeyBuilder {
  typedef PseudoKey Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_integer_value(int8_t integer_value) {
    fbb_.AddElement<int8_t>(PseudoKey::VT_INTEGER_VALUE, integer_value, 0);
  }
  void add_bool_value(bool bool_value) {
    fbb_.AddElement<uint8_t>(PseudoKey::VT_BOOL_VALUE, static_cast<uint8_t>(bool_value), 0);
  }
  void add_is_int(bool is_int) {
    fbb_.AddElement<uint8_t>(PseudoKey::VT_IS_INT, static_cast<uint8_t>(is_int), 0);
  }
  explicit PseudoKeyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PseudoKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PseudoKey>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PseudoKey> CreatePseudoKey(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t integer_value = 0,
    bool bool_value = false,
    bool is_int = false) {
  PseudoKeyBuilder builder_(_fbb);
  builder_.add_is_int(is_int);
  builder_.add_bool_value(bool_value);
  builder_.add_integer_value(integer_value);
  return builder_.Finish();
}

struct KeyValueString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyValueStringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueStringBuilder {
  typedef KeyValueString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(KeyValueString::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(KeyValueString::VT_VALUE, value);
  }
  explicit KeyValueStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyValueString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyValueString>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyValueString> CreateKeyValueString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  KeyValueStringBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyValueString> CreateKeyValueStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return Styles::CreateKeyValueString(
      _fbb,
      key__,
      value__);
}

struct Style FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StyleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DECLARATIONS = 4,
    VT_MEDIA = 6,
    VT_PSEUDO = 8,
    VT_PSEUDO_KEY = 10,
    VT_PSEUDO_VAL = 12,
    VT_SELECTOR = 14,
    VT_VARIABLES = 16
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::DeclarationTuple>> *declarations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::DeclarationTuple>> *>(VT_DECLARATIONS);
  }
  uint8_t media() const {
    return GetField<uint8_t>(VT_MEDIA, 0);
  }
  uint8_t pseudo() const {
    return GetField<uint8_t>(VT_PSEUDO, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::PseudoKey>> *pseudo_key() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::PseudoKey>> *>(VT_PSEUDO_KEY);
  }
  const ::flatbuffers::String *pseudo_val() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PSEUDO_VAL);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Selector>> *selector() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Selector>> *>(VT_SELECTOR);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValueString>> *variables() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValueString>> *>(VT_VARIABLES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DECLARATIONS) &&
           verifier.VerifyVector(declarations()) &&
           verifier.VerifyVectorOfTables(declarations()) &&
           VerifyField<uint8_t>(verifier, VT_MEDIA, 1) &&
           VerifyField<uint8_t>(verifier, VT_PSEUDO, 1) &&
           VerifyOffset(verifier, VT_PSEUDO_KEY) &&
           verifier.VerifyVector(pseudo_key()) &&
           verifier.VerifyVectorOfTables(pseudo_key()) &&
           VerifyOffset(verifier, VT_PSEUDO_VAL) &&
           verifier.VerifyString(pseudo_val()) &&
           VerifyOffset(verifier, VT_SELECTOR) &&
           verifier.VerifyVector(selector()) &&
           verifier.VerifyVectorOfTables(selector()) &&
           VerifyOffset(verifier, VT_VARIABLES) &&
           verifier.VerifyVector(variables()) &&
           verifier.VerifyVectorOfTables(variables()) &&
           verifier.EndTable();
  }
};

struct StyleBuilder {
  typedef Style Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_declarations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::DeclarationTuple>>> declarations) {
    fbb_.AddOffset(Style::VT_DECLARATIONS, declarations);
  }
  void add_media(uint8_t media) {
    fbb_.AddElement<uint8_t>(Style::VT_MEDIA, media, 0);
  }
  void add_pseudo(uint8_t pseudo) {
    fbb_.AddElement<uint8_t>(Style::VT_PSEUDO, pseudo, 0);
  }
  void add_pseudo_key(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::PseudoKey>>> pseudo_key) {
    fbb_.AddOffset(Style::VT_PSEUDO_KEY, pseudo_key);
  }
  void add_pseudo_val(::flatbuffers::Offset<::flatbuffers::String> pseudo_val) {
    fbb_.AddOffset(Style::VT_PSEUDO_VAL, pseudo_val);
  }
  void add_selector(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Selector>>> selector) {
    fbb_.AddOffset(Style::VT_SELECTOR, selector);
  }
  void add_variables(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValueString>>> variables) {
    fbb_.AddOffset(Style::VT_VARIABLES, variables);
  }
  explicit StyleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Style> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Style>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Style> CreateStyle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::DeclarationTuple>>> declarations = 0,
    uint8_t media = 0,
    uint8_t pseudo = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::PseudoKey>>> pseudo_key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pseudo_val = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Selector>>> selector = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::KeyValueString>>> variables = 0) {
  StyleBuilder builder_(_fbb);
  builder_.add_variables(variables);
  builder_.add_selector(selector);
  builder_.add_pseudo_val(pseudo_val);
  builder_.add_pseudo_key(pseudo_key);
  builder_.add_declarations(declarations);
  builder_.add_pseudo(pseudo);
  builder_.add_media(media);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Style> CreateStyleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Styles::DeclarationTuple>> *declarations = nullptr,
    uint8_t media = 0,
    uint8_t pseudo = 0,
    const std::vector<::flatbuffers::Offset<Styles::PseudoKey>> *pseudo_key = nullptr,
    const char *pseudo_val = nullptr,
    const std::vector<::flatbuffers::Offset<Styles::Selector>> *selector = nullptr,
    const std::vector<::flatbuffers::Offset<Styles::KeyValueString>> *variables = nullptr) {
  auto declarations__ = declarations ? _fbb.CreateVector<::flatbuffers::Offset<Styles::DeclarationTuple>>(*declarations) : 0;
  auto pseudo_key__ = pseudo_key ? _fbb.CreateVector<::flatbuffers::Offset<Styles::PseudoKey>>(*pseudo_key) : 0;
  auto pseudo_val__ = pseudo_val ? _fbb.CreateString(pseudo_val) : 0;
  auto selector__ = selector ? _fbb.CreateVector<::flatbuffers::Offset<Styles::Selector>>(*selector) : 0;
  auto variables__ = variables ? _fbb.CreateVector<::flatbuffers::Offset<Styles::KeyValueString>>(*variables) : 0;
  return Styles::CreateStyle(
      _fbb,
      declarations__,
      media,
      pseudo,
      pseudo_key__,
      pseudo_val__,
      selector__,
      variables__);
}

struct Font FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FontBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FONT_FAMILY = 4,
    VT_SRC = 6
  };
  const ::flatbuffers::String *font_family() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FONT_FAMILY);
  }
  const ::flatbuffers::String *src() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SRC);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FONT_FAMILY) &&
           verifier.VerifyString(font_family()) &&
           VerifyOffset(verifier, VT_SRC) &&
           verifier.VerifyString(src()) &&
           verifier.EndTable();
  }
};

struct FontBuilder {
  typedef Font Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_font_family(::flatbuffers::Offset<::flatbuffers::String> font_family) {
    fbb_.AddOffset(Font::VT_FONT_FAMILY, font_family);
  }
  void add_src(::flatbuffers::Offset<::flatbuffers::String> src) {
    fbb_.AddOffset(Font::VT_SRC, src);
  }
  explicit FontBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Font> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Font>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Font> CreateFont(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> font_family = 0,
    ::flatbuffers::Offset<::flatbuffers::String> src = 0) {
  FontBuilder builder_(_fbb);
  builder_.add_src(src);
  builder_.add_font_family(font_family);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Font> CreateFontDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *font_family = nullptr,
    const char *src = nullptr) {
  auto font_family__ = font_family ? _fbb.CreateString(font_family) : 0;
  auto src__ = src ? _fbb.CreateString(src) : 0;
  return Styles::CreateFont(
      _fbb,
      font_family__,
      src__);
}

struct PrimitiveCondition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PrimitiveConditionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATURE = 4,
    VT_OPERATOR_ = 6,
    VT_VALUE_TYPE = 8,
    VT_VALUE = 10
  };
  uint8_t feature() const {
    return GetField<uint8_t>(VT_FEATURE, 0);
  }
  uint8_t operator_() const {
    return GetField<uint8_t>(VT_OPERATOR_, 0);
  }
  Styles::Value value_type() const {
    return static_cast<Styles::Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Styles::String *value_as_String() const {
    return value_type() == Styles::Value_String ? static_cast<const Styles::String *>(value()) : nullptr;
  }
  const Styles::Integer *value_as_Integer() const {
    return value_type() == Styles::Value_Integer ? static_cast<const Styles::Integer *>(value()) : nullptr;
  }
  const Styles::Double *value_as_Double() const {
    return value_type() == Styles::Value_Double ? static_cast<const Styles::Double *>(value()) : nullptr;
  }
  const Styles::Boolean *value_as_Boolean() const {
    return value_type() == Styles::Value_Boolean ? static_cast<const Styles::Boolean *>(value()) : nullptr;
  }
  const Styles::StringArray *value_as_StringArray() const {
    return value_type() == Styles::Value_StringArray ? static_cast<const Styles::StringArray *>(value()) : nullptr;
  }
  const Styles::IntegerArray *value_as_IntegerArray() const {
    return value_type() == Styles::Value_IntegerArray ? static_cast<const Styles::IntegerArray *>(value()) : nullptr;
  }
  const Styles::DoubleArray *value_as_DoubleArray() const {
    return value_type() == Styles::Value_DoubleArray ? static_cast<const Styles::DoubleArray *>(value()) : nullptr;
  }
  const Styles::Object *value_as_Object() const {
    return value_type() == Styles::Value_Object ? static_cast<const Styles::Object *>(value()) : nullptr;
  }
  const Styles::ObjectArray *value_as_ObjectArray() const {
    return value_type() == Styles::Value_ObjectArray ? static_cast<const Styles::ObjectArray *>(value()) : nullptr;
  }
  const Styles::IntegereArrayArray *value_as_IntegereArrayArray() const {
    return value_type() == Styles::Value_IntegereArrayArray ? static_cast<const Styles::IntegereArrayArray *>(value()) : nullptr;
  }
  const Styles::DoubleArrayArray *value_as_DoubleArrayArray() const {
    return value_type() == Styles::Value_DoubleArrayArray ? static_cast<const Styles::DoubleArrayArray *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FEATURE, 1) &&
           VerifyField<uint8_t>(verifier, VT_OPERATOR_, 1) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Styles::String *PrimitiveCondition::value_as<Styles::String>() const {
  return value_as_String();
}

template<> inline const Styles::Integer *PrimitiveCondition::value_as<Styles::Integer>() const {
  return value_as_Integer();
}

template<> inline const Styles::Double *PrimitiveCondition::value_as<Styles::Double>() const {
  return value_as_Double();
}

template<> inline const Styles::Boolean *PrimitiveCondition::value_as<Styles::Boolean>() const {
  return value_as_Boolean();
}

template<> inline const Styles::StringArray *PrimitiveCondition::value_as<Styles::StringArray>() const {
  return value_as_StringArray();
}

template<> inline const Styles::IntegerArray *PrimitiveCondition::value_as<Styles::IntegerArray>() const {
  return value_as_IntegerArray();
}

template<> inline const Styles::DoubleArray *PrimitiveCondition::value_as<Styles::DoubleArray>() const {
  return value_as_DoubleArray();
}

template<> inline const Styles::Object *PrimitiveCondition::value_as<Styles::Object>() const {
  return value_as_Object();
}

template<> inline const Styles::ObjectArray *PrimitiveCondition::value_as<Styles::ObjectArray>() const {
  return value_as_ObjectArray();
}

template<> inline const Styles::IntegereArrayArray *PrimitiveCondition::value_as<Styles::IntegereArrayArray>() const {
  return value_as_IntegereArrayArray();
}

template<> inline const Styles::DoubleArrayArray *PrimitiveCondition::value_as<Styles::DoubleArrayArray>() const {
  return value_as_DoubleArrayArray();
}

struct PrimitiveConditionBuilder {
  typedef PrimitiveCondition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_feature(uint8_t feature) {
    fbb_.AddElement<uint8_t>(PrimitiveCondition::VT_FEATURE, feature, 0);
  }
  void add_operator_(uint8_t operator_) {
    fbb_.AddElement<uint8_t>(PrimitiveCondition::VT_OPERATOR_, operator_, 0);
  }
  void add_value_type(Styles::Value value_type) {
    fbb_.AddElement<uint8_t>(PrimitiveCondition::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(PrimitiveCondition::VT_VALUE, value);
  }
  explicit PrimitiveConditionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PrimitiveCondition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PrimitiveCondition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PrimitiveCondition> CreatePrimitiveCondition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t feature = 0,
    uint8_t operator_ = 0,
    Styles::Value value_type = Styles::Value_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  PrimitiveConditionBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  builder_.add_operator_(operator_);
  builder_.add_feature(feature);
  return builder_.Finish();
}

struct CompoundCondition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CompoundConditionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONDITIONS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Condition>> *conditions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Condition>> *>(VT_CONDITIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONDITIONS) &&
           verifier.VerifyVector(conditions()) &&
           verifier.VerifyVectorOfTables(conditions()) &&
           verifier.EndTable();
  }
};

struct CompoundConditionBuilder {
  typedef CompoundCondition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_conditions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Condition>>> conditions) {
    fbb_.AddOffset(CompoundCondition::VT_CONDITIONS, conditions);
  }
  explicit CompoundConditionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CompoundCondition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CompoundCondition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CompoundCondition> CreateCompoundCondition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Condition>>> conditions = 0) {
  CompoundConditionBuilder builder_(_fbb);
  builder_.add_conditions(conditions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CompoundCondition> CreateCompoundConditionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Styles::Condition>> *conditions = nullptr) {
  auto conditions__ = conditions ? _fbb.CreateVector<::flatbuffers::Offset<Styles::Condition>>(*conditions) : 0;
  return Styles::CreateCompoundCondition(
      _fbb,
      conditions__);
}

struct Condition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConditionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  Styles::ConditionValue value_type() const {
    return static_cast<Styles::ConditionValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Styles::PrimitiveCondition *value_as_PrimitiveCondition() const {
    return value_type() == Styles::ConditionValue_PrimitiveCondition ? static_cast<const Styles::PrimitiveCondition *>(value()) : nullptr;
  }
  const Styles::CompoundCondition *value_as_CompoundCondition() const {
    return value_type() == Styles::ConditionValue_CompoundCondition ? static_cast<const Styles::CompoundCondition *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyConditionValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Styles::PrimitiveCondition *Condition::value_as<Styles::PrimitiveCondition>() const {
  return value_as_PrimitiveCondition();
}

template<> inline const Styles::CompoundCondition *Condition::value_as<Styles::CompoundCondition>() const {
  return value_as_CompoundCondition();
}

struct ConditionBuilder {
  typedef Condition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(Condition::VT_TYPE, type, 0);
  }
  void add_value_type(Styles::ConditionValue value_type) {
    fbb_.AddElement<uint8_t>(Condition::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Condition::VT_VALUE, value);
  }
  explicit ConditionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Condition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Condition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Condition> CreateCondition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0,
    Styles::ConditionValue value_type = Styles::ConditionValue_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  ConditionBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Media FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MediaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CONDITIONS = 6
  };
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Condition>> *conditions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Condition>> *>(VT_CONDITIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyOffset(verifier, VT_CONDITIONS) &&
           verifier.VerifyVector(conditions()) &&
           verifier.VerifyVectorOfTables(conditions()) &&
           verifier.EndTable();
  }
};

struct MediaBuilder {
  typedef Media Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(Media::VT_ID, id, 0);
  }
  void add_conditions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Condition>>> conditions) {
    fbb_.AddOffset(Media::VT_CONDITIONS, conditions);
  }
  explicit MediaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Media> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Media>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Media> CreateMedia(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Condition>>> conditions = 0) {
  MediaBuilder builder_(_fbb);
  builder_.add_conditions(conditions);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Media> CreateMediaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t id = 0,
    const std::vector<::flatbuffers::Offset<Styles::Condition>> *conditions = nullptr) {
  auto conditions__ = conditions ? _fbb.CreateVector<::flatbuffers::Offset<Styles::Condition>>(*conditions) : 0;
  return Styles::CreateMedia(
      _fbb,
      id,
      conditions__);
}

struct StyleSheet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StyleSheetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FONTS = 4,
    VT_KEYFRAMES = 6,
    VT_MEDIAS = 8,
    VT_STYLES = 10,
    VT_DESIGN_WIDTH = 12
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Font>> *fonts() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Font>> *>(VT_FONTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *keyframes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_KEYFRAMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Media>> *medias() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Media>> *>(VT_MEDIAS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Style>> *styles() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Styles::Style>> *>(VT_STYLES);
  }
  uint16_t design_width() const {
    return GetField<uint16_t>(VT_DESIGN_WIDTH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FONTS) &&
           verifier.VerifyVector(fonts()) &&
           verifier.VerifyVectorOfTables(fonts()) &&
           VerifyOffset(verifier, VT_KEYFRAMES) &&
           verifier.VerifyVector(keyframes()) &&
           verifier.VerifyVectorOfStrings(keyframes()) &&
           VerifyOffset(verifier, VT_MEDIAS) &&
           verifier.VerifyVector(medias()) &&
           verifier.VerifyVectorOfTables(medias()) &&
           VerifyOffset(verifier, VT_STYLES) &&
           verifier.VerifyVector(styles()) &&
           verifier.VerifyVectorOfTables(styles()) &&
           VerifyField<uint16_t>(verifier, VT_DESIGN_WIDTH, 2) &&
           verifier.EndTable();
  }
};

struct StyleSheetBuilder {
  typedef StyleSheet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fonts(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Font>>> fonts) {
    fbb_.AddOffset(StyleSheet::VT_FONTS, fonts);
  }
  void add_keyframes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> keyframes) {
    fbb_.AddOffset(StyleSheet::VT_KEYFRAMES, keyframes);
  }
  void add_medias(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Media>>> medias) {
    fbb_.AddOffset(StyleSheet::VT_MEDIAS, medias);
  }
  void add_styles(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Style>>> styles) {
    fbb_.AddOffset(StyleSheet::VT_STYLES, styles);
  }
  void add_design_width(uint16_t design_width) {
    fbb_.AddElement<uint16_t>(StyleSheet::VT_DESIGN_WIDTH, design_width, 0);
  }
  explicit StyleSheetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StyleSheet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StyleSheet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StyleSheet> CreateStyleSheet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Font>>> fonts = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> keyframes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Media>>> medias = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Styles::Style>>> styles = 0,
    uint16_t design_width = 0) {
  StyleSheetBuilder builder_(_fbb);
  builder_.add_styles(styles);
  builder_.add_medias(medias);
  builder_.add_keyframes(keyframes);
  builder_.add_fonts(fonts);
  builder_.add_design_width(design_width);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StyleSheet> CreateStyleSheetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Styles::Font>> *fonts = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *keyframes = nullptr,
    const std::vector<::flatbuffers::Offset<Styles::Media>> *medias = nullptr,
    const std::vector<::flatbuffers::Offset<Styles::Style>> *styles = nullptr,
    uint16_t design_width = 0) {
  auto fonts__ = fonts ? _fbb.CreateVector<::flatbuffers::Offset<Styles::Font>>(*fonts) : 0;
  auto keyframes__ = keyframes ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*keyframes) : 0;
  auto medias__ = medias ? _fbb.CreateVector<::flatbuffers::Offset<Styles::Media>>(*medias) : 0;
  auto styles__ = styles ? _fbb.CreateVector<::flatbuffers::Offset<Styles::Style>>(*styles) : 0;
  return Styles::CreateStyleSheet(
      _fbb,
      fonts__,
      keyframes__,
      medias__,
      styles__,
      design_width);
}

inline bool VerifyValue(::flatbuffers::Verifier &verifier, const void *obj, Value type) {
  switch (type) {
    case Value_NONE: {
      return true;
    }
    case Value_String: {
      auto ptr = reinterpret_cast<const Styles::String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Integer: {
      auto ptr = reinterpret_cast<const Styles::Integer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Double: {
      auto ptr = reinterpret_cast<const Styles::Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Boolean: {
      auto ptr = reinterpret_cast<const Styles::Boolean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_StringArray: {
      auto ptr = reinterpret_cast<const Styles::StringArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_IntegerArray: {
      auto ptr = reinterpret_cast<const Styles::IntegerArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_DoubleArray: {
      auto ptr = reinterpret_cast<const Styles::DoubleArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Object: {
      auto ptr = reinterpret_cast<const Styles::Object *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_ObjectArray: {
      auto ptr = reinterpret_cast<const Styles::ObjectArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_IntegereArrayArray: {
      auto ptr = reinterpret_cast<const Styles::IntegereArrayArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_DoubleArrayArray: {
      auto ptr = reinterpret_cast<const Styles::DoubleArrayArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(
        verifier,  values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyConditionValue(::flatbuffers::Verifier &verifier, const void *obj, ConditionValue type) {
  switch (type) {
    case ConditionValue_NONE: {
      return true;
    }
    case ConditionValue_PrimitiveCondition: {
      auto ptr = reinterpret_cast<const Styles::PrimitiveCondition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConditionValue_CompoundCondition: {
      auto ptr = reinterpret_cast<const Styles::CompoundCondition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyConditionValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyConditionValue(
        verifier,  values->Get(i), types->GetEnum<ConditionValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const Styles::StyleSheet *GetStyleSheet(const void *buf) {
  return ::flatbuffers::GetRoot<Styles::StyleSheet>(buf);
}

inline const Styles::StyleSheet *GetSizePrefixedStyleSheet(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Styles::StyleSheet>(buf);
}

inline bool VerifyStyleSheetBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Styles::StyleSheet>(nullptr);
}

inline bool VerifySizePrefixedStyleSheetBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Styles::StyleSheet>(nullptr);
}

inline void FinishStyleSheetBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Styles::StyleSheet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStyleSheetBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Styles::StyleSheet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Styles

#endif  // FLATBUFFERS_GENERATED_STYLESHEET_STYLES_H_
